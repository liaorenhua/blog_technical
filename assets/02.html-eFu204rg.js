import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,l as a,o as n}from"./app-DNFRjLSh.js";const l="/blog_technical/assets/image-20210130221129447-BNy0EG8v.png",o={};function r(p,e){return n(),i("div",null,e[0]||(e[0]=[a('<h1 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法"><span>垃圾回收算法</span></a></h1><p>JDK 使用了一种算法，它的思想是：<strong>枚举根节点，做可达性分析</strong></p><figure><img src="'+l+'" alt="image-20210130221129447" tabindex="0" loading="lazy"><figcaption>image-20210130221129447</figcaption></figure><p>如上图所示，从根节点开始，引用了哪些对象，一层一层下去，最右侧的不可达，则它是一个垃圾</p><p>根节点有：类加载器、Thread、虚拟机栈的本地变量表、static 成员、常量引用、本地方法栈的变量等等。</p><p>确定垃圾之后，下面来介绍常用的垃圾回收方法</p><h2 id="标记清除" tabindex="-1"><a class="header-anchor" href="#标记清除"><span>标记清除</span></a></h2><p>算法：分为「标记」和「清除」两个阶段：</p><ul><li>标记：首先标记出所有需要回收的对象</li><li>清除：在标记完成后统一回收所有</li></ul><p>缺点：</p><ul><li>效率不高：标记和清除两个过程的效率都不高</li><li>产生碎片：碎片太多会导致提前 GC</li></ul><h2 id="复制" tabindex="-1"><a class="header-anchor" href="#复制"><span>复制</span></a></h2><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把自己使用过的内存空一次清理掉。</p><p>这种方式前面的 S0 和 S1 区就是使用的这种方式。</p><p>优缺点：实现简单，运行高效，但是空间利用率低。</p><h2 id="标记整理" tabindex="-1"><a class="header-anchor" href="#标记整理"><span>标记整理</span></a></h2><p>标记过程任然与 「标记清除」算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>优缺点：没有了内存碎片，但是整理内存比较耗时。</p><h2 id="分带垃圾回收" tabindex="-1"><a class="header-anchor" href="#分带垃圾回收"><span>分带垃圾回收</span></a></h2><ul><li><p>Young 区用复制算法</p><p>大部分对象生命周期非常短，存活的对象非常少，使用复制算法效率很高</p></li><li><p>Old 区用标记清除或标记整理</p><p>存放的对象，生命周期都是比较长的，垃圾相对较少，使用标记清除或标记整理较好</p></li></ul><h2 id="对象分配" tabindex="-1"><a class="header-anchor" href="#对象分配"><span>对象分配</span></a></h2><ul><li><p>对象优先在 Young 区中的 Eden 区分配</p></li><li><p>但是大对象会直接进入老年代 Old 区</p><p>对象的大小是通过 <code>-XX:PretenureSizeThreshold</code> 来定义的</p></li><li><p>长期存活的对象，将进入老年代</p><p><code>-XX:MaxTenuringThredhold</code>：最大年龄</p><p><code>-XX:+PrintTenuringDistribution</code>：发生 Young GC 的时候打印存活对象的年龄分布信息</p><p><code>-XX:TargetSurvivorRatio</code>：比例</p><p>在 Young 区的对象，不会一直存在 Young 区，经过几次垃圾回收，还存在 Young 区的则会晋升到 Old 区，每个对象都会有一个类型 <strong>年龄</strong> 的概念，每经过一次 Young GC，存活下来的对象年龄 + 1</p><p>当对象的年龄到达 <code>MaxTenuringThredhold</code> 岁时，将进入 Old 区</p><p>每次 Young GC 后，存活的对象如果大于 <code>TargetSurvivorRatio</code> 该值，则计算存活对象的平均年龄，达到该平均年龄的对象也会进入 Old 区</p></li></ul>',22)]))}const s=t(o,[["render",r],["__file","02.html.vue"]]),h=JSON.parse('{"path":"/monitor-tuning/06/02.html","title":"垃圾回收算法","lang":"zh-CN","frontmatter":{"tags":null,"description":"垃圾回收算法 JDK 使用了一种算法，它的思想是：枚举根节点，做可达性分析 image-20210130221129447image-20210130221129447 如上图所示，从根节点开始，引用了哪些对象，一层一层下去，最右侧的不可达，则它是一个垃圾 根节点有：类加载器、Thread、虚拟机栈的本地变量表、static 成员、常量引用、本地方法栈...","head":[["meta",{"property":"og:url","content":"https://www.pvzge.com/blog_technical/monitor-tuning/06/02.html"}],["meta",{"property":"og:title","content":"垃圾回收算法"}],["meta",{"property":"og:description","content":"垃圾回收算法 JDK 使用了一种算法，它的思想是：枚举根节点，做可达性分析 image-20210130221129447image-20210130221129447 如上图所示，从根节点开始，引用了哪些对象，一层一层下去，最右侧的不可达，则它是一个垃圾 根节点有：类加载器、Thread、虚拟机栈的本地变量表、static 成员、常量引用、本地方法栈..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-21T11:38:46.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-21T11:38:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"垃圾回收算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-21T11:38:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Leo\\",\\"url\\":\\"https://blog.csdn.net/liao_rh\\"}]}"]]},"headers":[{"level":2,"title":"标记清除","slug":"标记清除","link":"#标记清除","children":[]},{"level":2,"title":"复制","slug":"复制","link":"#复制","children":[]},{"level":2,"title":"标记整理","slug":"标记整理","link":"#标记整理","children":[]},{"level":2,"title":"分带垃圾回收","slug":"分带垃圾回收","link":"#分带垃圾回收","children":[]},{"level":2,"title":"对象分配","slug":"对象分配","link":"#对象分配","children":[]}],"git":{"createdTime":1734781126000,"updatedTime":1734781126000,"contributors":[{"name":"liao_rh","username":"liao_rh","email":"993929808@qq.com","commits":1,"url":"https://github.com/liao_rh"}]},"readingTime":{"minutes":2.42,"words":725},"filePathRelative":"monitor-tuning/06/02.md","localizedDate":"2024年12月21日","autoDesc":true}');export{s as comp,h as data};
